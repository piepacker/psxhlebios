#include "libpsxbios.h"
#include "psxhle-emu-ifc.h"
#include "psdisc-endian.h"

#include <list>

// Until code is ready
#define ASYNC_EVENT 1

#if HLE_DUCKSTATION_IFC
Log_SetChannel(HLEBIOS);
#endif

// Keep trace of the event status to only print change
static std::array<u8, 256> s_debug_ev;
static u8 s_print_waitevent_log = true;

void initEvents(u32 kernel_evcb) {
    // Setup Global pointer to event blocks
    StoreToLE(psxMu32ref(G_EVENTS), kernel_evcb | PS1_KernelSegment);
    StoreToLE(psxMu32ref(G_EVENTS_SIZE), SIZEOF_EVCB * EVCB_MAX);

    // Fill the struct with 0
    auto* evcb = PSXM(kernel_evcb);
    memset(evcb, 0, SIZEOF_EVCB * EVCB_MAX);

    // Init not-psx related data structure
    s_debug_ev.fill(0xFF);
    g_hle->async_event_nb = 0;
}

EVCB* GetEVCB() {
    u32 evcb_addr = LoadFromLE(psxMu32ref(G_EVENTS));
    return(EVCB*)PSXM(evcb_addr);
}

void DeliverEvent(u32 ev, u32 spec) {
#if 1
    // Quite spammy due to default kernel IRQ (vsync and timers)
    if (spec != EVENT_SPEC_INTERRUPT)
        PSXBIOS_LOG("DeliverEvent %8x;%x", ev, spec);
#endif

    auto evcb = GetEVCB();
    for (u32 i = 0; i < EVCB_MAX; i++) {
        if (evcb[i].status == EVENT_STATUS::ENABLED && evcb[i].ev == ev && evcb[i].spec == spec) {
            if (evcb[i].mode == EVENT_MODE::CALLBACK)
                softCall(evcb[i].fhandler);
            else
                evcb[i].status = EVENT_STATUS::DELIVERED;
        }
    }
}

void PostAsyncEvent(uint32_t ev, uint16_t spec, uint16_t port) {
    // Goal of event is to be allow asynchronous bios call execution. Using synchronous event work most of the
    // time but there are few caveats.
    // * Caveat1: An handler plugged on an event might not be reentrant, so you have the risk to run concurrent handler.
    //   See this example:
    //     Receive command1 event
    //     Execution of handler1
    //     Received command1 event because of synchronous event
    //       Execution of handler1
    //       ...
    //       Finish handler1
    //     Finish handler1
    // * Caveat2: you can infinite loop if the current event is triggered by an event generated by the same handler
#if ASYNC_EVENT
    if (g_hle->async_event_nb < countof(g_hle->async_events)) {
        PSXBIOS_LOG("PostAsyncEvent %8x;%x", ev, spec);
        auto& e = g_hle->async_events[g_hle->async_event_nb];
        e.ev = ev;
        e.spec = spec;
        e.port = port;
        g_hle->async_event_nb++;
    } else {
        PSXBIOS_LOG("ERROR: PostAsyncEvent %8x;%x (port=%d) can't be done ! async event stack full !!!", ev, spec, port);
        // Probably shouldn't happen
        dbg_check(false);
    }
#else
    DeliverEvent(ev, spec);
#endif
}

void DeliverAsyncEvent() {
#if ASYNC_EVENT == 0
    g_hle->busy_card_info = 0;
#endif

    if (g_hle->async_event_nb == 0)
        return;

    AsyncEventInfo events[countof(g_hle->async_events)];

    // swap event to a local var
    uint32_t nb = g_hle->async_event_nb;
    memcpy(events, g_hle->async_events, nb * sizeof(AsyncEventInfo));

    g_hle->async_event_nb = 0; // Just clear the number of event

    // Before we deliver anyc event, mark async command as done
    for (uint32_t i = 0; i < nb; i++) {
        if (events[i].port > 0x7FF) {
            // Invalid port. Clear all bits
            g_hle->busy_card_info = 0;
        } else {
            uint32_t port_flag = (1u << events[i].port);
            g_hle->busy_card_info &= ~port_flag;
        }
    }

    // Note: Delivering Event will updated async command status
    // (aka busy_card_info)
    for (uint32_t i = 0; i < nb; i++) {
        DeliverEvent(events[i].ev, events[i].spec);
    }
}

static int getFreeEventSlot() {
    auto evcb = GetEVCB();
    for (int i = 0; i < (int)EVCB_MAX; i++) {
        if (evcb[i].status == EVENT_STATUS::FREE) return i;
    }
    return -1;
}

void psxBios_DeliverEvent(HLE_BIOS_CALL_ARGS) { // 07
    PSXBIOS_LOG("psxBios_%s %x,%x", biosB0n[0x07], a0, a1);

    DeliverEvent(a0, a1);

    pc0 = ra;
}

void psxBios_OpenEvent(HLE_BIOS_CALL_ARGS) { // 08
    u32 evcb_max = LoadFromLE(psxMu32ref(G_EVENTS_SIZE)) / SIZEOF_EVCB;
    if (evcb_max != EVCB_MAX) {
        PSXBIOS_LOG("psxBios_OpenEvent() WARNING! max events was updated from %d to %d", EVCB_MAX, evcb_max);
        EVCB_MAX = evcb_max;
    }

    PSXBIOS_LOG("psxBios_%s (class:%x, spec:%x, mode:%x, func:%x)", biosB0n[0x08], a0, a1, a2, a3);

    auto slot = getFreeEventSlot();
    if (slot < 0) {
        v0 = slot;
        pc0 = ra;
        SysErrorPrintf("OpenEvent: no more slot available");
        return;
    } else {
        auto evcb = GetEVCB();
        evcb[slot].status = EVENT_STATUS::DISABLED; //  Don't use setOpenEventStatus to set status
        evcb[slot].ev = a0;
        evcb[slot].spec = a1;
        evcb[slot].mode = (EVENT_MODE)a2;
        evcb[slot].fhandler = a3;
    }

    v0 = slot | 0xf100'0000;
    pc0 = ra;

    SysPrintf("\t\t\tslot => %x", v0);
}

bool isValidSlot(u32 slot) {
    slot &= 0xFFFF;
    u32 evcb_max = LoadFromLE(psxMu32ref(G_EVENTS_SIZE)) / SIZEOF_EVCB;
    if (slot >= evcb_max) {
        // Game is buggy and depends on an "undefined" behavior
        // In order to behave like the original bios, we will need to have the same
        // start address for the EVCB...
        SysErrorPrintf("\t\t\t=> invalid slot (%x)", slot);
        return false;
    }

    return true;
}

void setOpenEventStatus(u32 slot, EVENT_STATUS status) {
    if (!isValidSlot(slot)) {
        return;
    }

    slot &= 0xFFFF;
    auto evcb = GetEVCB();
    if (evcb[slot].status != EVENT_STATUS::FREE)
        evcb[slot].status = status;
}

void psxBios_CloseEvent(HLE_BIOS_CALL_ARGS) { // 09
    PSXBIOS_LOG("psxBios_%s %x", biosB0n[0x09], a0);

    setOpenEventStatus(a0, EVENT_STATUS::FREE);

    v0 = 1;
    pc0 = ra;
}

void psxBios_WaitEvent(HLE_BIOS_CALL_ARGS) { // 0a
    uint32_t slot = a0 & 0xFFFF;
    if (!isValidSlot(slot)) {
        v0 = 0;
        pc0 = ra;
        return;
    }

    if (s_print_waitevent_log)
        PSXBIOS_LOG("psxBios_%s %x", biosB0n[0x0a], slot);

    auto evcb = GetEVCB();
    switch (evcb[slot].status) {
        case EVENT_STATUS::DELIVERED:
            // Event was delivered. Return valid and get back to enabled state
            // Callback events (mode=EVENT_MODE_CALLBACK) do never set the pending/delivered state (and thus WaitEvent would hang forever).
            if (evcb[slot].mode == EVENT_MODE::NO_CALLBACK) {
                evcb[slot].status = EVENT_STATUS::ENABLED;
            }
            v0 = 1;
            pc0 = ra;
            s_print_waitevent_log = true;
            break;

        case EVENT_STATUS::ENABLED:
            // Event wasn't delivered yet
            // 1/ advance time in the emulator. 200 is a random number. The minimum time for this call is around 30 ticks.
            // But this call is about halting the CPU waiting an event (IRQ), so it is expected to be slow
            AdvanceClock(200);
            // 2/ Emulate an infinite loop
            t1  = 0x0A;
            pc0 = 0xB0;
            // Let's avoid the spam
            s_print_waitevent_log = false;
            break;

        case EVENT_STATUS::DISABLED:
        case EVENT_STATUS::FREE:
        default:
            s_print_waitevent_log = true;
            // Event is invalid
            v0 = 0;
            pc0 = ra;
            break;
    }
}

void psxBios_TestEvent(HLE_BIOS_CALL_ARGS) { // 0b
    auto slot = a0 & 0xFFFF;
    if (!isValidSlot(slot)) {
        v0 = 0;
        pc0 = ra;
        return;
    }

    auto evcb = GetEVCB();
    if (evcb[slot].status == EVENT_STATUS::DELIVERED) {
        if (evcb[slot].mode == EVENT_MODE::NO_CALLBACK) {
            evcb[slot].status = EVENT_STATUS::ENABLED;
        }
        v0 = 1;
    } else {
        v0 = 0;
    }
    pc0 = ra;

    // Print only TestEvent change. The spamy part is the polling of the result
    //PSXBIOS_LOG_SPAM("TestEvent", "psxBios_%s %x,%x: result=%x", biosB0n[0x0b], ev, spec, v0);
    if (slot < s_debug_ev.size() && s_debug_ev[slot] != v0) {
        s_debug_ev[slot] = v0;
        PSXBIOS_LOG("psxBios_%s %x: result=%x", biosB0n[0x0b], slot, v0);
    }
}

void psxBios_EnableEvent(HLE_BIOS_CALL_ARGS) { // 0c
    PSXBIOS_LOG("psxBios_%s %x", biosB0n[0x0c], a0);

    setOpenEventStatus(a0, EVENT_STATUS::ENABLED);

    v0 = 1;
    pc0 = ra;
}

void psxBios_DisableEvent(HLE_BIOS_CALL_ARGS) { // 0d
    PSXBIOS_LOG("psxBios_%s %x", biosB0n[0x0d], a0);

    setOpenEventStatus(a0, EVENT_STATUS::DISABLED);

    v0 = 1;
    pc0 = ra;
}

void psxBios_UnDeliverEvent(HLE_BIOS_CALL_ARGS) { // 0x20
    PSXBIOS_LOG("psxBios_%s %x,%x", biosB0n[0x20], a0, a1);
    auto evcb = GetEVCB();
    for (u32 i = 0; i < EVCB_MAX; i++) {
        if (evcb[i].status == EVENT_STATUS::DELIVERED && evcb[i].ev == a0 && evcb[i].spec == a1) {
            if (evcb[i].mode == EVENT_MODE::NO_CALLBACK)
                evcb[i].status = EVENT_STATUS::ENABLED;
        }
    }
    pc0 = ra;
}

